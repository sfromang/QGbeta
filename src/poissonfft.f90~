!###########################################################
!> file poissonfft.f90
!! \brief
!! \b QGbeta:
!! This is poissonfft subroutines. It 
!! \details
!! Contains poissonfft(), initFFT()
!! \author
!! SÃ©bastien Fromang
!! \date
!! \b created:          18-06-2015 
!! \b last \b modified: 18-07-2015
!===============================================================================
!> Solve Poisson equation
!> if "withsource" is False, solve:
!> del^2 psi = q(i,j)
!> if "withsource" is True, solve:
!> del^2 psi = q(i,j) + 2/lambda^2*psi(i,j) 
!===============================================================================
subroutine poissonfft(sq,spsi,withSource)
  use params
  use user_params
  implicit none

  logical , intent(in) :: withSource
  complex(dp), dimension(1:nx,1:ny), intent(in ) :: sq
  complex(dp), dimension(1:nx,1:ny), intent(out) :: spsi
  real(dp) :: factor
  integer :: i,j

  factor=0.d0
  if (withSource) factor=lambdaInvSq
  spsi(1,1)=0.d0
  do j=2,ny
     do i=2,nx
        spsi(i,j)=-sq(i,j)/(kx2(i,j)+ky2(i,j)+2.d0*factor)
     end do
  end do
  do i=2,nx
     spsi(i,1)=-sq(i,1)/(kx2(i,1)+ky2(i,1)+2.d0*factor)
  end do
  do j=2,ny
     spsi(1,j)=-sq(1,j)/(kx2(1,j)+ky2(1,j)+2.d0*factor)
  end do

  return
end subroutine poissonfft
!===============================================================================
!> Initialize arrays for FFT depending on boundary conditions
!===============================================================================
subroutine initfft
  implicit none
  call computeWavenumbers
  return
end subroutine initfft
!===============================================================================
!> Compute wavenumbers
!===============================================================================
subroutine computeWavenumbers
  use params
  implicit none
  integer :: i,j
  real(dp) :: scalex,scaley

  allocate(kx(nx,ny),ky(nx,ny))
  scalex=twopi/(xmax-xmin)
  scaley=twopi/(ymax-ymin)

  do i=1,nx/2
     kx(i,:)=(i-1)
  end do
  do i=nx/2+1,nx
     kx(i,:)=(i-nx-1)
  end do
  kx = scalex * kx
  do j=1,ny/2
     ky(:,j)=(j-1)
  end do
  do j=ny/2+1,ny
     ky(:,j)=(j-ny-1)
  end do
  ky = scaley * ky

  if (typeBC==2) then
     
     allocate(kx2(nx,ny),ky2(nx,ny))

     ! Computing kx2
     do i=1,nx/2
        kx2(i,:)=+(i-1)*(i-1)
     end do
     do i=nx/2+1,nx
        kx2(i,:)=+(i-nx-1)*(i-nx-1)
     end do
     kx2 = scalex**2 * kx2

     ! Computing ky2
     ky2(1:nx,1)=0.d0
     do j=2,ny
        ky2(1:nx,j)=+(j-1)*(j-1)/4.
     end do
     ky2 = scaley**2 * ky2

  endif

  return
end subroutine computeWavenumbers
